#1   ---   c++和QML结合使用：
		1）思路：a.把c++类注册到QML中，成为一个QML类，再通过QML来创建和使用
			 b.把c++类实例化一个实例，然后把这个实例传给QML，QML直接使用对这个实例操作
		    小结：不论如何，都是把c++代码做成封装，给QML调用，这个和QML语言的实现思路是一致的，都是通过c++写底层，然后中间封装一层，再提供QML接口，
                          起始也就“相当于自己扩展开发QML语言了”

		2）准备：a.在c++类必须继承Qobject类
			 b.在c++类的开头必须使用Q_OBJECT宏

=========================================================================================================================================================

#2   ---   手段：1）通过信号和槽  互相关联
			 QML中有信号和槽，c++中也有信号和槽。而且QML和c++的信号和槽是互通的，那么就可以用这个机制来做关联。
			 在QML中注册信号和槽，来对应c++中的槽和信号。
				QML	 c++
				信号-----槽
				槽-------信号

		 2）通过Q_INVOKABLE宏  使用c++类方法
			凡是被此宏修饰的public成员方法都可以在QML中使用，使用方法就是  类名.方法

		 3）通过Q_ENUMS宏  使用c++类的枚举成员变量
			凡是被此宏处理过的枚举类型，都可以在QML中使用，方法为  类名.枚举的值  (这里不是 类名.枚举类型名.枚举的值)(那如果修饰了多个枚举类型怎么办？)

		 4）

=========================================================================================================================================================

如果想要模块化编程，那么就要单独定义一些模块，在QT里，这些可被其他qml引用的模块就叫做Component，Component类定义有两种，见#3

#3   ---   两种定义Component的方法：1）在其他qml文件中定义(嵌入式)                       见：动态加载/1
				    2）在以自己名字定义的qml文件中定(单独文件式)         见：动态加载/2
				
#4   ---   两种使用Component的方法：1）直接使用文件名					 见：动态加载/2
				    2）使用Loader类					 见：动态加载/1，动态加载/3

=========================================================================================================================================================

#5   ---   在QT中，信号触发就是函数调用
	   有两种触发信号的方法：1）直接使用   id.func()  ,  即直接使用实例+信号函数的方式  （这里信号函数是使用signal关键字声明函数） ， 这种情况仅适合在同一个qml文件中。跨文件的id不共享
				 2）通过emit，如果一个qml文件或者c++文件中想使用另一个qml文件中通过signal定义的信号函数，则必须使用emit函数来触发，表示”此时此刻我要发信号了“，也就是会说
                                    ”此时此刻我要调用信号处理函数了“
	   
=========================================================================================================================================================

#6   ---   在c++和QT中，signal关键字修饰的信号，其实是一个对象，它有connect方法和disconnect方法。可以使用它连接到任意的方法(函数)上。

=========================================================================================================================================================

#7   ---   接#6，举个例子：
                
		Rectangle{
			id:relay
			
			signal messageReceived(string person,string notice);	//创建一个信号实例，叫messageReceived，此信号可携带的参数列表为 person 和 notice
			
			Component.onComplete:{
			    relay.messageReceived.connect(sendToPost);		//   为信号实例注册一个信号处理函数sendToPost
			    relay.messageReceived.connect(sendToTelegraph);	//再 为信号实例注册一个信号处理函数sendToTelegraph
			    relay.messageReceived.connect(sendToEmail);		//再 为信号实例注册第三个信号处理函数sendToEmail
				
			    relay.messageReceived("xxx","yyy")			//触发信号，可以理解为为信号实例messageReceived”“”“调用构造函数”“”“
			}
			
			function sendToPost(person,notice){
					func(person,notice);			//处理传进来的参数person和notice
			}
			function sendToTelegraph(xxx,yyy){
					func(xxx,yyy);				//处理传进来的参数xxx和yyy，这里具体参数叫什么名字不重要，只要知道对应于信号的两个参数就行了
			}
			function sendToEmail(person,notice){
					func(person,notice);
			}
		}

=========================================================================================================================================================

#8   ---  onXxxxed:{
	    ...
	  }
          上述形式声明信号处理函数，其实对应了三条语句：1） signal xxxxed();
							2） function func(){
								...
							    }   
							3） xxxxed.connect(func);

		ps:因为信号的本质是函数，所以可以有函数调用的嵌套，即触发信号后，在信号处理函数中再触发信号。（恩，这是理所应当的，如果不能嵌套调用就太2了）

=========================================================================================================================================================

#9   ---  信号的定义、使用、挂载本文件的处理函数、挂载其他文件的处理函数、在任何地方对某个信号实例增加信号处理函数  
			
				见：信号与槽/1

=============================================================   c++和QML   =======================================================================

#10  ---  QML起始是ECMAScript的扩展，QML虽然由QT c++实现，但是二者是平行存在的，如果想互相访问，就必须在中间建立起一个桥梁

		提供两种手段，来实现这个桥梁：
		1）使用c++实现类，然后注册这个类为QML元素(就好像Button、Rectangle一样)，接着就可以当做QML元素使用了。  （把c++类注册入qml环境，当做qml元素使用）
		2）使用c++实现类，然后创建一个c++实例，再把这个实例注入QML中，接着就可以使用这个QML实例了。	       （把c++类实例化，然后带入QML上下文中）

			二者的区别：一个是注册一个类型进去，可以无限实例化;一个是注册一个实例进去，只有一个

			共同点：   都是把c++类注入QML环境


#11  --- 接#10，既然都是要定义c++类，或者使用已有的类，那么就对于类的定义就有要求：
		1）如果是新定义的类，那么必须继承QObject ，即 class myclass : public QObject。
		   如果是已有的类，那么这个类如果没继承自QObject，那么需要重新继承一次
		2）在类的定义.h文件中，开头使用Q_OBJECT宏声明一下


#12  ---  1)  c++中的方法，可以使用Q_INVOKABLE来修饰，之后这些方法就能直接在QML中使用了
	  2)  c++中的成员变量，可以使用Q_PROPERTY来修饰，。。。。。。。。。。
	  3)  c++中的枚举类型，可以使用Q_ENUMS来修饰，。。。。。。。。。。。 enum类型需要在c++类中定义
	  4)  c++中定义的信号signal，可以再QML中直接使用，不需要修饰，在c++中定义的时候直接是
			signals:
				clicked(string a,string b);
				pressed(string a);
				changed();
	  5)  c++中定义的槽slots(就是信号处理函数，xxxed.connect(func),就是connect的参数)，可以再QML中直接使用，不需要修饰，在c++中的定义为
			public slots:
				func1();
				func2(string a,string b);
	  6)  上面这些元素的访问权限修饰和c++中一样，public、private和protected都可以用，代表不同的可见性

	注：c++成员变量的定义，直接就在Q_PROPERTY里面做了，但是enum类型不行，宏修饰Q_ENUMS和定义enum xxx{ ... }需要分开来
	    成员函数的定义(声明)，也和成员比那辆一样，直接使用Q_INVOKABLE修饰就完事了
	    就enum类型和别人不一样，修饰和定义要分开
	    
            (!!!)信号和槽比较特殊，不需要修饰

#13  --- 10~12说了如何定义一个c++类，才能让QML能调用之。	即如何定义类
	 那么现在说怎么样注册进去。				即如何注册类

	 一句话：在任何想用的地方(正常的思维就是在main函数中)，使用qmlRegisterType函数来注册。
	   
	但是，qmlRegisterType是一个模板函数，那么现在我想明确指定模板参数T的类型，那么就需要使用到显示实例化(/home/yangkun/Git/Code-plusplus/Basic/函数模板/4.cpp)

	例如：qmlRegisterType<ColorMaker>("../src/",1,0,"MyColorMaker");  
	 //源码路径为../src，
	//ColorMaker为需要注册为qml类型的c++类(即自定义组件的c++源码)
	//MycolorMaker为再qml中使用ColorMaker时，使用的名称。比如在main.qml中想用ColorMaker这个c++类，只要使用MycolorMaker{ }创建即可
		

#14  ---  10~12说了  如何定义类
	  13 说了    如何注册类
	  现在说     在其他文件中如何引入这写注册的类(可以联想c中的include，java中的import)

		没什么多说的，就是使用import，加上类的路径，和java一模一样，比如上面的ColorMaker，如果工程根目录是  project1,cpp文件在project1/src/
			
				那么就有
					import project1.src.ColorMaker 1.0;

#15  --- 前面说了       定义类
			注册类
			引入类
	 现在说		使用类

		一旦通过上述步骤后，使用类就是水到渠成，和Button，Rectangle这些源生类，“”“”“”一模一样“”“”“”
		不赘述了！！！！！！！！


#16  ---  10~15介绍了如何导入 c++类 为 QML类型，并在QML中使用
	  之前说了还有一种是直接导入c++实例到QML中。二者在步骤上的差异如下：

		导入QML类型需要2步：	1）在响应的qml中import                  
                    			2）在main函数中qmlRegisterType 
		使用实例只需要1步：	1）在main函数中setContextProperty        

		但是，使用QML类型更直接和通用，使用实例会有很多棘手的问题需要解决。比如不能通过类名访问枚举成员变量





#17  ---  前面说了如何在qml中使用c++对象，下面说如何在c++中使用qml对象。
	  只要记住一条：“”“确定使用qml的某个类后(比如Button，Rectangle等等)，就可以通过QT的元对象系统，来访问这个类的成员方法，成员变量(如果public)，信号和槽“”“


#18  ---  思路：1）在元对象系统中找到某个qml文件的根元素（最外层的那个元素），然后获取其引用。
		2）把引用传递给需要使用这个元素的c++类
		3）通过findchild来创建根元素下所有子元素的引用，进而使用这些元素。

	针对1），因为main.cpp都会指定从那个qml开始启动项目，并且使用一个QQmlApplicationEngine类来加载这个qml文件，所以这个qml的根元素就是整个工程的根元素
	然后使用engine.rootObjects()来获取这个根元素的引用


#19  ---  使用：一旦创建了对相关子元素的应用(#18中的第三步完成后)，那么可以通过如下方法来使用这些qml元素：
		1）使用invokeMethod()来调用qml元素注册到元对象系统中的方法
		2）使用property()来访问qml元素的成员变量
	



=============================================================   c++和QML   =======================================================================



  

#20  ---  一个qml文件中只能有一个跟节点，比如xxx.qml
		Rectangle{
		    id:r1
		}
		Rectangle{
		    id:r2
		}
	  这样就不行，需要用一个Item(或者Item的子类)，或者Component或者其他可以作为根节点的类包裹，比如
		Rectangle{
		    id:rroot
			Rectangle{
    			    id:r1
			}		
			Rectangle{
			    id:r2
			}			
		}






























