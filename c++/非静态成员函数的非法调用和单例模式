如果编译时报错“非静态成员函数的非法调用”，
1)那就是在静态成员函数中，在没创建实例的情况下，就使用非静态成员函数了。
2)或者静态成员变量或者静态成员函数处在非静态成员函数中了。


在c++中，静态成员函数是独立于实例的，程序运行后自动加载到静态内存区。因此即使某个类一个实例也没有用，静态成员函数都是存在的
。这也是所有类实例能够共享静态成员函数和静态成员变量的原因。
但是，这也引出了一个问题，那就是静态成员函数里面"没法使用非静态成员变量和调用非静态成员函数"

因此，如果想使用非静态成员变量和非静态成员函数，那么必须在第一个调用非静态成员函数内，创建一个实例。这样便可以使用其他
非静态的成员变量和成员和函数了。

这也引出了另一个问题，如果某个函数里面有静态成员函数和成员变量，那么“这函数也一定是静态的”。

================================================================================================================

于是乎，这也导致了单例模式的实现机制 ———— 使用静态成员函数，给静态成员变量赋值。比如：

alarmhandler.h

class AlarmHandler{

public:
	static AlarmHandler* createAlarmHandler();		//静态成员函数，用来创建单例

private:
	AlarmHandler::AlarmHandler();				//private的构造函数，这样createAlarmHandler就是类
								//的唯一入口了，那么在入口做一个NULL检查就实现了单例

}




alarmhandler.cpp

static AlarmHandler * myAlarmHandler = NULL;			//静态成员变量，用来存放单例指针

AlarmHandler *AlarmHandler::createAlarmHandler()
{
	if(myAlarmHandler == NULL)
	{		
		myAlarmHandler = new AlarmHandler();		
	}
	return myAlarmHandler;
}

AlarmHandler::AlarmHandler()
{
}


小结：静态成员函数比实例先被创建，其他的成员函数和变量在类未创建时，“都是不存在的”（还没有被分配到堆里面），但是构造函数
	是可以调用的，因为构造函数本身是一个分配内存的函数，是特别的。因此单例模式的中心思想就是 “使用静态成员函数这个
	独立于实例的东西，来调用能够分配内存的 ‘构造函数’”

	但是，单例的使用，必须要求以后使用都不在使用“构造函数”来创建实例，转而使用指定的静态成员函数来创建，当然，也可以
	通过构造函数来创建实例，这样就拜托了单例模式，也是去了设计模式的意义。
	（PS：单例模式其实要求构造函数是private，这样外界是没法使用构造函数的）

	总的来说，单例模式 是一种 巧计， 巧妙利用static成员变量被所有实例共享这一特点，同时把构造函数设计成private，让
	外界不可调用，这样静态成员函数就成了这个类的唯一入口，那么我在入口的地方在做一次筛选，判断如果当前已经有实例，就
	不再调用构造函数，这样就实现了到哪里模式
